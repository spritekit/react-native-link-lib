diff --git a/node_modules/react-native-popover-view/dist/AdaptivePopover.js b/node_modules/react-native-popover-view/dist/AdaptivePopover.js
index 79d7acc..f8a988a 100644
--- a/node_modules/react-native-popover-view/dist/AdaptivePopover.js
+++ b/node_modules/react-native-popover-view/dist/AdaptivePopover.js
@@ -276,7 +276,8 @@ var AdaptivePopover = /** @class */ (function (_super) {
                         this.debug('calculateRectFromRef - waiting for ref to move from', initialRect);
                         count = 0;
                         _d.label = 4;
-                    case 4: return [4 /*yield*/, getRectForRef(fromRef)];
+                    case 4: 
+                    return [4 /*yield*/, getRectForRef(this.props.fromRef)];
                     case 5:
                         rect = _d.sent();
                         if ([rect.x, rect.y, rect.width, rect.height].every(function (i) { return i === undefined; })) {
diff --git a/node_modules/react-native-popover-view/dist/Utility.js b/node_modules/react-native-popover-view/dist/Utility.js
index d326cb0..4bf1017 100644
--- a/node_modules/react-native-popover-view/dist/Utility.js
+++ b/node_modules/react-native-popover-view/dist/Utility.js
@@ -37,15 +37,18 @@ var __generator = (this && this.__generator) || function (thisArg, body) {
 import { StyleSheet } from 'react-native';
 import { Placement, Rect, Size } from './Types';
 import { DEFAULT_ARROW_SIZE, DEFAULT_BORDER_RADIUS } from './Constants';
+import { log } from 'node:console';
 export function getRectForRef(ref) {
-    return new Promise(function (resolve, reject) {
-        if (ref.current) {
-            ref.current.measureInWindow(function (x, y, width, height) {
-                return resolve(new Rect(x, y, width, height));
-            });
-        }
-        else {
-            reject(new Error('getRectForRef - current is not set'));
+    return new Promise(function (resolve) {
+        try {
+            if (ref.current) {
+                ref.current?.measureInWindow(function (x, y, width, height) {
+                    return resolve(new Rect(x, y, width, height));
+                });
+            }
+          
+        } catch (error) {            
+            resolve(new Rect(180, 400, 0, 0));
         }
     });
 }
diff --git a/node_modules/react-native-popover-view/src/AdaptivePopover.tsx b/node_modules/react-native-popover-view/src/AdaptivePopover.tsx
index 562312d..dc9cc92 100644
--- a/node_modules/react-native-popover-view/src/AdaptivePopover.tsx
+++ b/node_modules/react-native-popover-view/src/AdaptivePopover.tsx
@@ -30,44 +30,14 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
     showing: false
   }
 
-  getUnshiftedDisplayArea(): Rect {
-    return this.props.displayArea ||
-      this.state.defaultDisplayArea ||
-      new Rect(0, 0, Dimensions.get('window').width, Dimensions.get('window').height);
-  }
-
-  // Apply insets and shifts if needed
-  getDisplayArea(): Rect {
-    const { displayAreaInsets } = this.props;
-    const displayArea = this.state.shiftedDisplayArea || this.getUnshiftedDisplayArea();
-    if (displayAreaInsets) {
-      this.debug('[AdaptivePopover] getDisplayArea - displayAreaInsets', displayAreaInsets);
-      return new Rect(
-        displayArea.x + (displayAreaInsets.left ?? 0),
-        displayArea.y + (displayAreaInsets.top ?? 0),
-        displayArea.width - (displayAreaInsets.left ?? 0) - (displayAreaInsets.right ?? 0),
-        displayArea.height - (displayAreaInsets.top ?? 0) - (displayAreaInsets.bottom ?? 0)
-      );
-    }
-    return displayArea;
-  }
-
-  /*
-   * This is used so that when the device is rotating
-   * or the viewport is expanding for any other reason,
-   * we can suspend updates due to content changes until
-   * we are finished calculating the new display
-   * area and rect for the new viewport size.
-   * This makes the recalc on rotation much faster.
-   */
   private waitForResizeToFinish = false;
-
   private skipNextDefaultDisplayArea = false;
   private displayAreaStore: Rect | undefined;
   private _isMounted = false;
   private keyboardDidHideSubscription: EmitterSubscription | null = null;
   private keyboardDidShowSubscription: EmitterSubscription | null = null;
   private handleResizeEventSubscription: EmitterSubscription | null = null;
+  private cleanupTimers: NodeJS.Timeout[] = [];
 
   constructor(props: AdaptivePopoverProps) {
     super(props);
@@ -85,19 +55,40 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
 
   componentWillUnmount(): void {
     this._isMounted = false;
+    this.cleanupTimers.forEach(timer => clearTimeout(timer));
+    this.cleanupTimers = [];
 
     if (typeof this.handleResizeEventSubscription?.remove === 'function')
       this.handleResizeEventSubscription?.remove();
     else
-      // Backward-compatibility with RN <= 0.63
       Dimensions.removeEventListener('change', this.handleResizeEvent);
 
     this.keyboardDidShowSubscription?.remove();
     this.keyboardDidHideSubscription?.remove();
   }
 
+  getUnshiftedDisplayArea(): Rect {
+    return this.props.displayArea ||
+      this.state.defaultDisplayArea ||
+      new Rect(0, 0, Dimensions.get('window').width, Dimensions.get('window').height);
+  }
+
+  getDisplayArea(): Rect {
+    const { displayAreaInsets } = this.props;
+    const displayArea = this.state.shiftedDisplayArea || this.getUnshiftedDisplayArea();
+    if (displayAreaInsets) {
+      this.debug('[AdaptivePopover] getDisplayArea - displayAreaInsets', displayAreaInsets);
+      return new Rect(
+        displayArea.x + (displayAreaInsets.left ?? 0),
+        displayArea.y + (displayAreaInsets.top ?? 0),
+        displayArea.width - (displayAreaInsets.left ?? 0) - (displayAreaInsets.right ?? 0),
+        displayArea.height - (displayAreaInsets.top ?? 0) - (displayAreaInsets.bottom ?? 0)
+      );
+    }
+    return displayArea;
+  }
+
   componentDidUpdate(prevProps: AdaptivePopoverProps): void {
-    // Make sure a value we care about has actually changed
     const importantProps = ['fromRef', 'fromRect', 'displayArea'];
     const changedProps = getChangedProps(this.props, prevProps, importantProps);
     if (!changedProps.length) return;
@@ -126,8 +117,6 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
     }
   }
 
-
-  // First thing called when device rotates
   handleResizeEvent(change: unknown): void {
     this.debug('handleResizeEvent - New Dimensions', change);
     if (this.props.isVisible) {
@@ -144,12 +133,6 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
     if (!this._isMounted) return;
 
     const { defaultDisplayArea }: Partial<AdaptivePopoverState> = this.state;
-
-    /*
-     * When the popover is closing and the display area's onLayout event is called,
-     * the width/height values may be zero which causes a bad display area for the
-     * first mount when the popover re-opens
-     */
     const isValidDisplayArea = newDisplayArea.width > 0 && newDisplayArea.height > 0;
     if (
       (!defaultDisplayArea || !newDisplayArea.equals(defaultDisplayArea)) &&
@@ -160,16 +143,15 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
         const displayAreaOffset = await this.props.getDisplayAreaOffset();
         this.debug('setDefaultDisplayArea - displayAreaOffset', displayAreaOffset);
         await new Promise(resolve => {
-          this.setState(
-            { defaultDisplayArea: newDisplayArea, displayAreaOffset },
-            () => resolve(null)
-          );
+          const timer = setTimeout(() => {
+            this.setState(
+              { defaultDisplayArea: newDisplayArea, displayAreaOffset },
+              () => resolve(null)
+            );
+          }, 0);
+          this.cleanupTimers.push(timer);
         });
 
-        /*
-         * If we have a ref, then changing the display area may have resulted in the view moving,
-         * so need to poll and see if it moves
-         */
         if (this.props.fromRef) {
           await this.calculateRectFromRef();
         }
@@ -183,10 +165,9 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
     }
   }
 
-  // Custom type here, as KeyboardEvent type does not contain endCoordinates
   keyboardDidShow(e: { endCoordinates: { height: number } }): void {
-    this.debug(`keyboardDidShow - keyboard height: ${e.endCoordinates.height}`);
-    this.shiftForKeyboard(e.endCoordinates.height);
+    this.debug(`keyboardDidShow - keyboard height: ${e?.endCoordinates?.height}`);
+    this.shiftForKeyboard(e?.endCoordinates?.height??300);
   }
 
   keyboardDidHide(): void {
@@ -196,7 +177,6 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
 
   shiftForKeyboard(keyboardHeight: number): void {
     const displayArea = this.getUnshiftedDisplayArea();
-
     const absoluteVerticalCutoff =
       Dimensions.get('window').height - keyboardHeight - (isIOS ? 10 : 40);
     const combinedY = Math.min(displayArea.height + displayArea.y, absoluteVerticalCutoff);
@@ -216,9 +196,9 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
     let count = 0;
     while (!fromRef?.current) {
       await new Promise(resolve => {
-        setTimeout(resolve, 100);
+        const timer = setTimeout(resolve, 100);
+        this.cleanupTimers.push(timer);
       });
-      // Timeout after 2 seconds
       if (count++ > 20) return;
     }
 
@@ -248,9 +228,9 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
       }
 
       await new Promise(resolve => {
-        setTimeout(resolve, 100);
+        const timer = setTimeout(resolve, 100);
+        this.cleanupTimers.push(timer);
       });
-      // Timeout after 2 seconds
       if (count++ > 20) return;
 
     } while (!AdaptivePopover.hasRetrievedSatisfyingRect(rect, initialRect));
@@ -260,17 +240,12 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
   }
 
   static hasRetrievedSatisfyingRect = (rect: Rect, initialRect: Rect): boolean =>
-    /*
-     * Checking if x and y is less than -1000 because of a strange issue on Android related
-     * to the "Toggle from" feature, where the rect.y is a large negative number at first
-     */
     !(rect.equals(initialRect) || rect.y < -1000 || rect.x < -1000)
 
   render(): ReactNode {
     const { onOpenStart, onCloseStart, onCloseComplete, fromRef, ...otherProps } = this.props;
     const { fromRect, showing } = this.state;
 
-    // Don't render popover until we have an initial fromRect calculated for the view
     if (fromRef && !fromRect && !showing) return null;
 
     return (
@@ -308,6 +283,5 @@ export default class AdaptivePopover extends Component<AdaptivePopoverProps, Ada
         onDisplayAreaChanged={rect => this.setDefaultDisplayArea(rect)}
       />
     );
-
   }
 }
diff --git a/node_modules/react-native-popover-view/src/Utility.ts b/node_modules/react-native-popover-view/src/Utility.ts
index f1ca74c..a8595dc 100644
--- a/node_modules/react-native-popover-view/src/Utility.ts
+++ b/node_modules/react-native-popover-view/src/Utility.ts
@@ -8,15 +8,16 @@ type RefType = RefObject<{
 }>;
 
 export function getRectForRef(ref: RefType): Promise<Rect> {
-  return new Promise((resolve, reject) => {
-    if (ref.current) {
-      ref.current.measureInWindow(
-        (x: number, y: number, width: number, height: number) =>
-          resolve(new Rect(x, y, width, height))
-      );
-    } else {
-      reject(new Error('getRectForRef - current is not set'));
-    }
+  return new Promise((resolve) => {
+    try {
+      if (ref.current) {
+          ref.current?.measureInWindow(function (x, y, width, height) {
+              return resolve(new Rect(x, y, width, height));
+          });
+      }
+  } catch (error) {            
+      resolve(new Rect(180, 400, 0, 0));
+  }
   });
 }
 
